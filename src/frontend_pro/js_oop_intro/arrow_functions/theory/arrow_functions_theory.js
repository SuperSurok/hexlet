///// Пример №1
// На уровне модуля контестом будет сам модуль
'use strict'
const f1 = () => {
    console.log('f1:', this);
};
f1();

function f2() {
    console.log('f2:', this);
}

f2();
///// Пример №2
const obj = {
    f1,
    f2,
};

console.log(`obj.f1(): ${obj.f1()}`); // undefined
console.log(`obj.f2(): ${obj.f2()}`); // { f1: [Function: f1], f2: [Function: f2] }
// Обычная функция ожидаемо связалась с контекстом того объекта, на котором была вызвана.
// А в случае стрелочной функции такого не произошло. Так как стрелочная функция не имеет своего контекста,
// она связывается с лексическим окружением, то есть функцией, внутри которой определена стрелочная функция.
// Это очень важный момент. Именно функция задаёт контекст, а не что-то другое.
// И это определение нельзя изменить с помощью call или bind.
console.log(`f1.call(obj): ${f1.call({ name: 'Hexlet' })}`);
console.log(`f1.bind(obj): ${f1.bind({ name: 'Hexlet' })}`);

/// Определим функцию внутри объекта
const company = {
    f1: () => {
        console.log(this);
    },
    f2() {
        console.log(this);
    },
};
// Несмотря на то, что стрелочная функция описыватеся внутри объекта и вызвается из этого же объекта
// контекст всё равно связан с местом определения фунуции (лексическим окружением) - а это сам модуль.

console.log(`company.f1() ${company.f1()}`); // {}
console.log(`company.f2() ${company.f2()}`); // { f1: [Function: f1], f2: [Function: f2] }

// Определение стрелочной функции внутри другой функции
const printer = {
    items: [1],
    print() {
        // важно, что внешняя функция имеет контекст
        // Стрелочная функция определяется внутри функции print,
        // но вызывается внутри forEach()
        this.items.forEach(() => console.log(this.items));
    }
};
console.log(printer.print());
// Стрелочная функция заимствует контекст у внешней функции print
// Она вызвается напрямую, а не из объекта
// Обчные функции в такой ситуации теряют контекст
const printer2 = {
    items: [1],
    print() {
        this.items.forEach(function () { console.log(this.items); })
    },
};
console.log(printer2.print());

// Отсутсвие своего контекста делает невозможным использование оператота new
// вместе со стрелочными функциями
const f = () => {};
// TypeError: function is not constructor
const obj1 = new f();
